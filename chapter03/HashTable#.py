"""
dict的实现及其导致的结果
下面的内容会讨论使用散列表给 dict 带来的优势和限制都有哪些。
01. 键必须是可散列的
    一个可散列的对象必须满足以下要求。
    (1) 支持 hash() 函数,并且通过 __hash__() 方法所得到的散列
    值是不变的。
    (2) 支持通过 __eq__() 方法来检测相等性。
    (3) 若 a == b 为真,则 hash(a) == hash(b) 也为真。
    所有由用户自定义的对象默认都是可散列的,因为它们的散列值由
    id() 来获取,而且它们都是不相等的。
    如果你实现了一个类的 __eq__ 方法,并且希望它是可
    散列的,那么它一定要有个恰当的 __hash__ 方法,保证在 a
    == b 为真的情况下 hash(a) == hash(b) 也必定为真。否则
    就会破坏恒定的散列表算法,导致由这些对象所组成的字典和
    集合完全失去可靠性,这个后果是非常可怕的。另一方面,如
    果一个含有自定义的 __eq__ 依赖的类处于可变的状态,那就
    不要在这个类中实现 __hash__ 方法,因为它的实例是不可散
    列的。
02. 字典在内存上的开销巨大
    由于字典使用了散列表,而散列表又必须是稀疏的,这导致它在空
    间上的效率低下。举例而言,如果你需要存放数量巨大的记录,那
    么放在由元组或是具名元组构成的列表中会是比较好的选择;最好不
    要根据 JSON 的风格,用由字典组成的列表来存放这些记录。用
    元组取代字典就能节省空间的原因有两个:其一是避免了散列表所
    耗费的空间,其二是无需把记录中字段的名字在每个元素里都存一
    遍。
    在用户自定义的类型中,__slots__ 属性可以改变实例属性的存储
    方式,由 dict 变成 tuple,相关细节在 9.8 节会谈到。
    记住我们现在讨论的是空间优化。如果你手头有几百万个对象,而
    你的机器有几个 GB 的内存,那么空间的优化工作可以等到真正需
    要的时候再开始计划,因为优化往往是可维护性的对立面。
03. 键查询很快
    dict 的实现是典型的空间换时间:字典类型有着巨大的内存开
    销,但它们提供了无视数据量大小的快速访问——只要字典能被装
    在内存里。正如表 3-5 所示,如果把字典的大小从 1000 个元素增
    加到 10 000 000 个,查询时间也不过是原来的 2.8 倍,从 0.000163
    秒增加到了 0.00456 秒。这意味着在一个有 1000 万个元素的字典
    里,每秒能进行 200 万个键查询。
04. 键的次序取决于添加顺序
    当往 dict 里添加新键而又发生散列冲突的时候,新键可能会被安
    排存放到另一个位置。于是下面这种情况就会发生:由
    dict([key1, value1), (key2, value2)] 和 dict([key2,
    value2], [key1, value1]) 得到的两个字典,在进行比较的时
    候,它们是相等的;但是如果在 key1 和 key2 被添加到字典里的
    过程中有冲突发生的话,这两个键出现在字典里的顺序是不一样
    的。
05. 往字典里添加新键可能会改变已有键的顺序
    无论何时往字典里添加新的键,Python 解释器都可能做出为字典扩
    容的决定。扩容导致的结果就是要新建一个更大的散列表,并把字
    典里已有的元素添加到新表里。这个过程中可能会发生新的散列冲
    突,导致新散列表中键的次序变化。要注意的是,上面提到的这些
    变化是否会发生以及如何发生,都依赖于字典背后的具体实现,因
    此你不能很自信地说自己知道背后发生了什么。如果你在迭代一个
    字典的所有键的过程中同时对字典进行修改,那么这个循环很有可
    能会跳过一些键——甚至是跳过那些字典中已经有的键。
    由此可知,不要对字典同时进行迭代和修改。如果想扫描并修改一
    个字典,最好分成两步来进行:首先对字典迭代,以得出需要添加
    的内容,把这些内容放在一个新字典里;迭代结束之后再对原有字
    典进行更新。

set的实现以及导致的结果
    set 和 frozenset 的实现也依赖散列表,但在它们的散列表里存放的
    只有元素的引用(就像在字典里只存放键而没有相应的值)。在 set 加
    入到 Python 之前,我们都是把字典加上无意义的值当作集合来用的。
    在 3.9.3 节中所提到的字典和散列表的几个特点,对集合来说几乎都是
    适用的。为了避免太多重复的内容,这些特点总结如下。
    1.集合里的元素必须是可散列的。
    2.集合很消耗内存。
    3.可以很高效地判断元素是否存在于某个集合。
    4.元素的次序取决于被添加到集合里的次序。
    5.往集合里添加元素,可能会改变集合里已有元素的次序。
"""